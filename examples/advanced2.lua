local copas = require "copas"
local mio = require "minittp_io"

--
-- This example presents a downloadable file, which is dynamically
-- generated by the data_outputter.sh script.
-- it will download until the user calls the page '/stop'
--

local handler = {}
handler.download_running = false
handler.bytes_sent = 0

function handler:index(request, response)
    response.content = [[<html>
    <head>
        <title>Downloader with stop function example</title>
<script type="application/javascript">
function reload() {
    setInterval(function(){window.location.reload();}, 1000);
}
</script>
    </head>
    <body onload="reload()">
        <p>description goes here</p>
        <p><a href="/download" target="_blank" onClick="window.location.reload()">Start download</a></p>
]]
    if self.download_running then
        response.content = response.content ..
        "        <p>Bytes sent: " .. self.bytes_sent .. "</p>\n" ..
        "        <p><a href=\"/stop\">Stop download</a></p>\n"
    else
        response.content = response.content ..
        "        <p>Bytes sent: " .. self.bytes_sent .. "</p>\n" ..
        "        <p>Download not running</p>\n"
    end
    response.content = response.content ..
[[    </body>
</html>
]]
    return response
end

function handler:download(request, response)
    self.download_running = true
    self.bytes_sent = 0
    response:set_header("Transfer-Encoding", "chunked")
    response:set_header("Content-Disposition",  "attachment; filename=\"download_file.txt\"")
    response:send_status()
    response:send_headers()
    
    subp, err = mio.subprocess("../examples/data_outputter.sh", {"example data"}, 0, true, false, false)
    if subp == nil then
        print("[XX] error starting process: " .. err)
        return nil
    end
    while self.download_running do
        copas.sleep(0.1)
        line, err = subp:read_line(false)
        if line == nil then
            print("[XX] error reading from subprocess: " .. err)
            if err ~= "read timed out" then
                sent, err = response:send_chunk("")
                print("not timeout error")
                subp:kill()
                subp:close()
                return
            end
        else
            sent, err = response:send_chunk(line)
            if sent == nil then
                sent, err = response:send_chunk("")
                print("Error sending data: " .. err)
                subp:kill()
                subp:close()
                return nil
            else
                -- do not count the \r\n that signals end of chunk
                self.bytes_sent = self.bytes_sent + sent - 2
            end
        end
    end
    subp:kill()
    subp:close()
    sent, err = response:send_chunk("")
    if sent == nil then
        print("Error sending data: " .. err)
    end
    self.download_running = false
    return nil
end

function handler:stop_download(request, response)
    self.download_running = false
    response:set_header("Location", "/")
    response:set_status(302, "Found")
    return response
end

function handler:init()
end

function handler:handle_request(request, response)
    local request_uri = request.path
    if request.path == "/" then return self:index(request, response)
    elseif request.path == "/stop" then return self:stop_download(request, response)
    elseif request.path == "/download" then return self:download(request, response)
    else
        response:set_status(404, "NOTFOUND")
        response.content = "Not found"
        return response
    end
end

return handler
